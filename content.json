{"pages":[{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"About","text":"我叫陳弘毅，過去同事們習慣叫我的英文名字 Brian，過去 2 ~ 3 年專注在網頁前端、APP 開發，前端熟悉 React/React Native 生態系，後端熟悉 Node.js 生態系，參與過 4 個 production 專案，有建置 React E2E 測試經驗。目前希望由前端轉向後端開發。 我熱愛學習以及挑戰，過去團隊中，每當要分配 sprint 的 ticket 的時候，我總是第一個爭取做最複雜、困難的功能，即便當下我可能對這個要開發功能完全不了解，但我願花大量時間研究、實作且在每個 sprint 都能準時交付功能，也因此在過去的兩年內，我重構了系統主功能、建置 E2E 測試、實作藍芽功能、實作 iOS widget 與 React Native 串接，為了加強基礎以及學習後端開發，我在今年 3 月離職，專注在將基礎打穩和學習後端開發，因為我希望我能不只當一個前端工程師 我熱愛分享，過去在前公司，我常常在週會分享看到的新技術或設計方式，其實包含推廣 Typescript 、React Hooks 和 React 元件設計模式等等，我熱愛學習、更熱愛與人分享以及交流我的學習成果，因為我深信教學就是學習最好的方式 Hello! My name is Brian. I’m a frontend/APP developer has over 3 years experience. Familiar with React and Node.js ecosystem. My primary programming language is TypeScript. Participated in four production projects. Have experience build E2E testing infrastructure and CI process. Currently seeking for opportunities to transition from frontend development to backend development. I love learning and challenges. In the past 2 years , i always the one willing to take on the most complex and challenging task when assigning ticket every sprint. Even though, i didn’t fully understand how to develop the feature or functionality. I would spend a lot time to survey and implement the feature and deliver the requirement on time. Therefore, in past two years, i refactored core functionality in project, construct E2E test, implement bluetooth and iOS Widget on React Native project. I left my previous company in this March for learning more about the fundamental of computer science and backend development because i want to be more than a frontend dev. I love sharing my learnings. At previous company, i often shared new technologies and design pattern on weekly meeting including TypesScript, React Hooks, React component design patterns and more. Because i believe in teaching is the best way of learning.","link":"/about/index.html"}],"posts":[{"title":"Linux Command 入門(一)","text":"Linux 指令基本結構Command 結構: command 名稱 + option + inputs, command 是有分大小寫的 命令是如何被執行的:$PATH 定義了可執行檔的位置，輸入命令後，會在有定義 $PATH 的文件夾中找尋執行檔，如果某個執行某個執行檔的名稱相同，會由最左邊的檔案夾被執行 which: 找到此命令的執行檔位置 command 可以接受多個參數: 找 2017 年 12 月的月曆 長、短 option: -v 是短 option, --version 是長 option, 但是不一定會有長 option 手冊頁 Manual Page每個 command 都有各自的參數，可以透過查詢手冊頁來知道用法跟參數 手冊頁結構 加粗的是常用命令區塊 Section 內容 備註 1 User Commands 一般不需要權限的命令 ex: cal, date 2 System Calls 多半使用在應用程式裡，可以向 Linux Kernal 下的命令 3 C Library Functions 給 C 語言用的 Library functions 4 Devices and Sepcial Files 管理裝置，ex：光碟機、USB Port 5 File Formats and Convetions 6 Games 7 Miscellaneous Protocals, File systems 相關資訊 8 System Administration 需要權限的命令, ex: 改密碼、編輯重要文件、設定自動化等… 使用 Manual Page找尋相關命令語法: man -k {你要找的命令}ex: 與 which 相關的 command, 我們要找的 which 命令在最後一個，然後括號裡面的 1 代表它在 section 1 查看命令 Man Page語法： man {section} {你要找的命令},ex: 下 man 1 which, 找在 section 1 的 which 命令，section 1 的命令因為太常用，所以可以省略 1Man page 裡符號解釋： [] 表示選則性的選項, [-a | -f] 表示能使用 -a 和 -f 其中一個選項， ...: 表示可以多個參數 &lt;&gt;: 代表必填 以下為舉例，非真實 command： command [-a] &lt;filename&gt; ...: 有 -a 這個選擇性選項，且 fileanme 為必填，可多個 command [-a | -f] &lt;path&gt;: 有 -a 和 -f 兩個選擇性選項，並需要給一個 path 參數 command [OPTION]... [FILE]...: 可選擇性使用多個 option, 和多個 file 參數, 但因為都是 optional 的，因此可以直接使用 command","link":"/2021/07/23/Linux-Command-%E5%85%A5%E9%96%80-%E4%B8%80/"},{"title":"Linux Command 入門(二)","text":"了解 Command 的輸入與輸出方式，如何傳遞 Command 的結果給下個 Command，可以讓你真正感受到 Shell 的強大，廢話不多說就馬上開始吧！ Command 的 Input 和 Output給 Command輸入的資料可以是 Standard Input 或者是參數, Command 執行完的結果是 Standard Output 或是Standard Error，Standard Output 和 Error 預設的輸出位置是 Terminal Standard Input: 預設是鍵盤輸入 我們用 cat command 舉例，我們先查看 cat 指令的 man page說明寫著，如果沒有給 file 參數的話，就會從 standard input 讀取 我們試試看只給 cat command 不給參數後，我們就可以打字用 input 給 cat Rediretion將 Standard Iput, Out, Error 的 data stream 轉向非 terminal 的地方 每個 data stream 都有其代表的數字 standard input: 0 standard output: 1 standard error: 2 ExampleStandard Output 範例:cat 1&gt; output.txt 裡的 1 就代表 standard output, &gt; 代表輸出的位置，也可以省略 1 cat &gt; output.txt 如果你已經有 output.txt 檔了，Linux 會其清空檔案後再輸入，術語叫 truncation，如果你不想要原本檔案的資料被清空，則可以用 cat &gt;&gt; output.txt, &gt;&gt; 為 appending 的符號Standard Error 範例: cat -k bla 2&gt; error.txtStandard Output 和 Error 都輸出: cat 1&gt; output.txt 2&gt;error.txtStandard Input: 我們讀取一個檔案的資料當作 standard input, cat 0&lt; inpput.txt 或是 cat &lt; inpput.txt 練習: 利用 cat command 讀取某個檔案的內容後寫入 hello.txt答案: cat &lt; input.txt &gt; hello.txt Piping利用 | 符號可以將 command 的 standard output 轉為下個 command 的 standard input，並且可以不斷接下去 語法: command1 [-options] [args] | command2 [-options] [args] | ... Q: 如果我們現在希望將 date 指令的第一個欄位的值，該怎麼做呢？ 利用 redirection: 將 date 指令的 output 存在 date.txt: date &gt; date.txt cut 指令讀取 date.txt 後再取第一個欄位: cut &lt; date.txt -d &quot; &quot; -f 1 利用 Piping: 將 date 的 standard output 轉為 cut standard input 然後執行:date | cut -d &quot; &quot; -f 1 tee 指令當我們希望指令的輸出可以同時產生檔案跟變為下個指令的輸入時，我們可以利用 tee 指令，tee 指令就像多了一個出口的水管Q: 如果我們想 date 將完整的日期寫入 full_date.txt 同時取得 date 輸出的第一個欄位，指令該怎麼寫？A: date | tee full_date.txt | cut -d &quot; &quot; -f 1 xargs某些指令不接受 standard input，只接受 command args, 像是 echo 指令，但我們可以使用 xargs 來接前面指令 piping 過來的 standard input 轉換成 command args，給 echo 指令當參數 ex: date | xargs echo","link":"/2021/07/26/Linux-Command-%E5%85%A5%E9%96%80-%E4%BA%8C/"},{"title":"Linux | Understand Permissions","text":"Unix or Unux-like system like mac or linux allow multiple users in a single machine.As regular users, we don’t have permission to write or even read every file on the machine.For example, if i try to read the file /etc/sudoers using cat . I get a “permission denied” message. Groups On unix systems, a single user may be the owner of files and directories, meaning that they have control over their access. Additionally, users can belong to groups which are given access to particular files and folders by their owners. File Type The very first charater indicates the type of the file. Some of the more common types and their corresponding attributes are: -: regular file d: directory c: character special file I: symbolic link Understand Permissons permission: owner, group, world(anyone else) Permissions Character Effect On Files Effect On Directions r file can read directory’s content can be listed w file can be modified directory’s contents can be modified (create new files, rename files/folders) but only if the executable attribute is also set x file can be treated as a program be executed allows a directory to be entered or “cd”ed into - file cannot be read, modified or executed depending on the location of the - character directory contents cannot","link":"/2021/07/27/Understand-Linux-Permissions/"},{"title":"Linux | Alter Permissions","text":"chmodTo change the permissions of a file or directory, we can use the chmod command (change mode). To use chmod to alter permissions, we need to tell it: Who we are changing permission for? What change are we making? Adding? Removing? Which permissions are we setting? chmod mode file who u: user(the owner of the file) g: group(members of the group the file belongs to) o: other(the “world”) a: all of the above what -: removes the permission +: grants the permission =: set a permission and removes others which r: the read permission w: the write permission x: the execute permission ExampleAdd write permissions to the group chmod g+w file.txt Remove write permissions from all chmod a-w file.txt Add executable permissions for owner chmod u+x file.txt Set permissions to read ONLY for all chmod a=r file.txt Add permissions to read and executable to the file chmod u+wx happy.txt chmod Octals (base 8)chmod also supports another way of representing permission patterns: octal numbers(base 8). Each digit in an octal number represents 3 binary digits. Octal Binary File Mode 0 000 — 1 001 –x 2 010 -w- 3 011 -wx 4 100 r– 5 101 r-x 6 110 rw- 7 111 rwx ExampleQ: Alter the file permissions to user: rw_ group: r__ other: r__ A: User Group Other Octal 6 4 4 Binary 110 100 100 Permissions rw_ r__ r__ chmod 644 file.txt Change Identity (su command)We can use the su command to start a shell as another user within our shell session. change the currnet shell user to “kitty”NOTE: - or --login option will change the current directory, it is the recommanded option to prevent side effects caused by mixing environments. su - kitty using exit command to exit the enviroment of the subsitube user. Root UserThe root user can run any command and access any file on the machine, regardless of the file’s actual owner. Based on the reason above, the root user could easily damage the system by running wrong command. Therefore, Ubuntu locks the root user by default. Using The Sudo CommandEven if the root user is locked by default, we can still run specific commands as the root user by using the sudo command. Chaning ownwership (Chown command)The chown command is used to change the owner and/or the group owner of a specific file or directory. ExampleMake “kevin” the owner of file.tx sudo chown kevin file.txt Make “test_group” as the group owner of file.txt chown :test_group file.txt","link":"/2021/07/28/Linux-Alter-Permissions/"},{"title":"Python 基礎語法","text":"此篇是集結 Python \b\b所有的基礎語法內容，我將此篇當作學習筆記，需要用到時才回來複習，\b但未覆蓋到 List Unpacking 的用法，關於 List Unpacking 的使用方式可以參考 Mike 的這篇文章 Python Unpacking實用技巧分享 Data Type int float bool str list: 動態的 Array， Javascript Array 類似 tuple: 可以想成是 immuable 的 listmy_tuple = (1, 2, 3) set: collection of uniqe valuesmy_set = {1, 2, 3, 4, 5} dict: Javascript 的 Object, Java 的 HashMap Ternary Expressionis_lisenced = Trueword = \"I can sense that lisence in you\" if is_lisenced else \"get out\" Truthy and Falsey以下為 Falsey 值， 其他皆視為 Truthy 值 None False 0 0.0 0j decimal.Decimal(0) fraction.Fraction(0, 1) [] - an empty list {} - an empty dict () - an empty tuple '' - an empty str b'' - an empty bytes set() - an empty set an empty range, like range(0) objects for which obj.__bool__() returns False obj.__len__() returns 0 is vs ==== 檢查值是否相同, 如果非相同的型別，python 會試著轉型別 print(True == 1) # True, pythonthon compare True == bool(1)print('' == 1) # Falseprint([] == 1) # Falseprint(10 == 10.0) # Trueprint([] == []) # True is 檢查記憶體地址是否相同 print(True == 1) # Falseprint('' == 1) # Falseprint([] == 1) # Falseprint(10 == 10.0) # Falseprint([] == []) # False for Loops and Iteratorfor item in 'Brian': print(item) Iterate Objectuser = { \"name\": \"Brain\", \"age\": 28, \"can_swim\": True}for item in user.items(): print(item) for key, value in user.items(): print(key, value) 用 range()for item in range(100): print(item) 如果你不需要用參數的話: for _ in range(100): print('haha') while loopi = 0while i &lt; 50: print(i) i += 1else: print('Done with all the work') 如果用 Break 的話就不會跑 else 的程式 i = 0while i &lt; 50: print(i) i += 1 breakelse: print('Done with all the work') continue在迴圈裡用 continue, 就會略過迴圈裡 continue 以後的程式，直接跑下一個迴圈 my_list = [1, 2, 3]for item in my_list: print('haha') continue print(item) # 此行永遠不會跑 i = 0while i &lt;len(my_list): print(my_list[i]) i += 1 continue print(i) # 此行永遠不會跑 Function*args 跟 *kwargs*_args:_ 將所有的 arugements 轉為 tuple def super_func(*args): print(args) # (1, 2, 3, 4, 5) super_func(1, 2, 3, 4, 5) *_kwargs:_ 將所有的 arguments 轉為 dict def super_func(**kwargs): print(kwargs) # { name: \"Brian\", age: 27 } super_func(name='Brian', age=27) 同時使用 def super_func(*args, **kwargs): print(args) # (1, 2, 3) print(kwargs) # { name: \"Brian\", age: 27 } super_func(1, 2, 3, name='Brian', age=27) 如果要使用多種不同的參數順序: params, *args, default params, **kwargs Function Docstring可以利用 docstring 幫 function 進行註解 def test(): ''' Info: this function tests and prints param a string ''' print('Hello world') Walrus OperatorBefore: a = 'Helloooooooooooo'if (len(a) &gt; 10): print(f\"Too long {len(a)} letters\") After: a = 'Helloooooooooooo'if ((n := len(a)) &gt; 10): print(f\"Too long {n} letters\") 變數 Scope順序為 是否為 local 變數 是否為 parent 層 local 變數 是否為 global 變數 是否為內建 method global如果要在 function 裡, 用 global 的變數, 則需要用 global keyword totoal = 0def count(): global total total += 1 return total print(count()) 但不推薦這麼做，可以直接將 global 的變數丟進 function 裡閱讀性較好 nonlocal在 function 裡使用 parent function 的變數, 則需要用 nonlocal keyword def outter(): x = \"local\" def inner(): nonlocal x x = \"nonlocal\" print(x) inner() print(\"outer:\", x)outer() classclass Player(): # constructor def __init__(self, name): self.name = name # method, 所有的 method 第一個參數都是 self def run (self): print('run') @classmethod, @staticmethod用來新增 class 本身的 method, 不需要 instantiate 就可以使用 與一般 method 不同，@classmethod 的第一個參數是自己本身的 class, @staticmethod 則沒有任何預設參數 class Player(): def __init__(self, name): self.name = name @classmethod def sum(cls, num1, num2): return num1+num2 @staticmethod def sum2(num1, num2): return num1+num2 Inheritance子 class 需要利用該 Class名稱.__init__() 或是 super().__init__() 將父 class init 需要的直傳入Class名稱.__init__(): 第一個參數要傳入 self class Person(): def __init__(self, name, age): self.name = name self.age = age def greeting(self): print(f'Hello, my name is {self.name} and i am {self.age} years old')class Wizard(Person): def __init__(self, name, age, power): Person.__init__(self, name, age) self.power = power super().__init__(): 不需傳入 self class Person(): def __init__(self, name, age): self.name = name self.age = age def greeting(self): print(f'Hello, my name is {self.name} and i am {self.age} years old')class Wizard(Person): def __init__(self, name, age, power): super().__init__(name, age) self.power = power def attack(self): print(f'attacking with power of {self.power}') Multiple Inheritanceclass Wizard: def __init__(self, name, power): self.name = name self.power = power def magic_attack(self): print(f'{self.name} shoot the magic fire ball with {self.power} damage') class Archer: def __init__(self, name, arrow_count): self.name = name self.arrow_count = arrow_count def shoot_arrow(self): print(f'{self.name} shoot {self.arrow_count} arrows')class HybridMan(Wizard, Archer): def __init__(self, name, power, arrow_count): Wizard.__init__(self, name, power) Archer.__init__(self, name, arrow_count) super_man = HybridMan('Super Man', 10000, 500)super_man.magic_attack()super_man.shoot_arrow() MRO - Method Resolution Orderclass A: num = 10class B(A): passclass C(A): num = 1class D(B, C): pass print(D.num) # 1 # 繼承圖 A / \\ B C \\ / D # method 執行順序為 D -&gt; B -&gt; C -&gt; A# 可以使用 .mro() 得到執行順序 D.mro() Dunder Methodspython 裡所有東西都是 object, 當我們在創建一個物件時，就會繼承底層 object 的 methods, 所有你看到的 __xxx__ 屬性都是繼承底層 object 來的 method, 但我們也可以通過覆寫去重新實作這些 method 假設我們想要覆寫 __str__ method class Toy(): def __init__(self, color): self.color = color def __str__(self): return f'{self.color}' toy = Toy('Yellow')print(toy.__str__()) # yellowprint(str(toy)) # yellow __name__: 檔案(模組)的名稱, 如果是執行的檔案則是 __main__ functional programmingBuild in methodsmap my_list = [1, 2, 3]def multiply(num): return num * 2mapObject = map(multiply, my_list)new_list = list(mapObject) filter test_list = [1, 2, 3]def is_odd(num): return num % 2 != 0odd_numbers = list(filter(is_odd, test_list)) zip test_list = [1, 2, 3]test_list2 = [\"David\", \"Amy\", \"John\"]def is_odd(num): return num % 2 != 0zipped_list = list(zip(test_list, test_list2))print(zipped_list)# ------------------# output:# [(1, 'David'), (2, 'Amy'), (3, 'John')]# ------------------ reduce from functools import reducemy_list = [1, 2 ,3]def accumulator(acc, number): return acc + numberprint(reduce(accumulator, my_list, 0)) Lambda 語法: lambda param: action(param) test_list = [1, 2, 3,]# mapmap(lambda num: num * 2, my_list)# filterlist(filter(lambda num: num % 2 != 0, my_list))# reducereduce(lambda acc, num: acc + num, my_list, 0)# List Sortinga = [(0,2), (4,3), (9,9), (10, -1)]a.sort(key=lambda x: x[1])print(a) list, set, dictionary comprehension這是一個只有 pythonthon 獨有的語法糖before: my_list = []for char in \"Heloo\": my_list.append(char) after: my_list = [char for char in 'hello'] 其他範例: my_list2 = [num for num in range(0, 200)] 如果我想讓 output 的數字都乘2 my_list2 = [num*2 for num in range(0, 200)] 加上 condition # **是 power 的意思# if 後面是結果篩選的條件my_list2 = [num**2 for num in range(0, 100) if num % 2 == 0] Dictionary Example: my_dict = {num:num*2 for num in [1,2,3]}print(my_dict)#--------------# output: {1: 2, 2: 4, 3: 6}#-------------- simple_dict = { 'a': 1, 'b': 2}my_dict = {key:value**2 for key, value in simple_dict.items()}print(my_dict)#--------------# output: { 'a': 1, 'b': 4 }#-------------- 加上 condition simple_dict = { 'a': 1, 'b': 2}my_dict = {k:v**2 for k,v in simple_dict.items()if v%2 == 0}print(my_dict)#--------------# output: { 'b': 4 }#-------------- DecoratorHigher Order function以下兩種都算是 higher order function 參數為 function def greet(func): func() 返回 function def greet(): def func(): return 5 return func Decorator function 的格式只要符合以下格式就可以當 decorator function, 所以事實上 decorator 只是 higher order function 的語法糖 def my_decorator(func): def wrap_func(): print(\"開始執行~\") func() print(\"執行成功 😀😀😀😀\") return wrap_func 使用: @my_decoratordef hello(): print(\"我是一個 function\")hello()#-----------# output: # 開始執行~# 我是一個 function# 執行成功 😀😀😀😀#----------- 以下兩個語法相等Higher Order Function 版： def hello(): print(\"我是一個 function\") wrap_func = my_decorator(hello)wrap_func() Decorator 版: @my_decoratordef hello(): print(\"我是一個 function\")hello() 傳參數傳單個參數 def my_decorator(func): def wrap_func(param): print(\"----------\") func(param) print(\"----------\") return wrap_func 傳多個參數: 利用 list unpacking def my_decorator(func): def wrap_func(*args, **kwargs): print(\"----------\") func(*args, **kwargs) print(\"----------\") return wrap_func Error HandlingBuilt-In Error 語法 while(True): try: age = int(input('What is your age?')) 10/age except: print('Please enter a number') else: print('Thank you!') break 抓特定 exception這邊我們想要抓使用者打 0 的時候的，10/0 發生的錯誤, while(True): try: age = int(input('What is your age?')) 10/age except ValueError: print('Please enter a number') except ZeroDivisionError: print('Please enter age higher than 0') else: print('Thank you!') break 使用 Error 物件 def sum(num1, num2): try: return num1 + num2 except TypeError as err: print(f'Please enter numbers {err}') 一次抓取兩種錯誤 def sum(num1, num2): try: return num1/num2 except (TypeError, ZeroDivisionError) as err: print(f'Error: {err}') 利用 finally keyword while(True): try: age = int(input('What is your age?')) except ValueError: print('Please enter a number') except ZeroDivisionError: print('Please enter age higher than 0') else: print('Thank you!') break finally: print('ok, i am finally done') 用 raise keyword主動發出 Error有時候我們想要針對特定邏輯主動發起錯誤，這時候我們就可以用 raise keyword def sum(num1, num2): try: number = num1/num2 if (number &lt; 0): raise ValueError('The number should be positive') return number except (TypeError, ZeroDivisionError) as err: print(f'Error: {err}') Generator語法Example 01 def generator_function(num): for i in range(num): yield i*2 generator = generator_function(100)print(next(generator)) # output: 0print(next(generator)) # output: 2print(next(generator)) # output: 4 Example 02 def gen_func(num): for i in range(num): yield ifor i in gen_func(10): print(i) Modules假設我現在除了 main.py 以外還以一個 utilities.py 的檔案在同一個檔案夾import 整個 file import utilitiesnum = utilies.mutiply(2, 3) import 個別變數和 methods注意：如果 import 的 method 與 built in method 撞名, 會執行 import 的 method, 或是可以用 as keyword 將 import 的 method 改名 from utilities import multiply, dividenum = multiply(2,3) 如果要 import 檔案夾裡面的檔案，python 會把檔案夾當作是 package # import 整個模組import folder_name.file_name# import methodfrom folder_name.file_name import the_method","link":"/2021/07/29/Python-Basic/"},{"title":"Python 檔案讀寫(File I/O)","text":"my_file = open('your_file.txt')text = my_file.read()print(text) # hello worldmy_file.close() 推薦 file i/o 寫法, 使用 with 就不需要使用 file.close() 來關閉檔案 with open('your_file.text') as my_file: text = my_file.read() print(text) 寫入open 第二個參數是讀寫模式, read:r write:w append：a create: x read and write: r+ (寫入的方式為 Append, 如果你要讀加上覆寫檔案，就只能先用 r mode 讀取再用 w mode 寫入) with open('test.txt', mode = 'w') as my_file: text = my_file.write('hello, i am brain') print(text) 錯誤處理try: with open('test.txt', mode = 'r') as my_file: print(my_file.read())except FileNotFoundError as err: print('file does not exist')except IOError as err: print('IO error') raise err 練習利用 translate 套件，讀取英文檔案後翻譯成中文, 寫入另一個檔案 from translate import Translatortranslation = ''try: with open('test.txt', 'r') as file: text = file.read() translator = Translator(to_lang=\"zh\") translation = translator.translate(text) with open('translation.txt', 'w') as my_file2: my_file2.write(translation)except (IOError, FileNotFoundError) as err: print(err)","link":"/2021/07/30/Python-%E6%AA%94%E6%A1%88%E8%AE%80%E5%AF%AB-I-O/"},{"title":"React Native Beacon 功能開發","text":"什麼是低功耗藍芽低功耗藍芽是藍芽 4.0 後因應物聯網(IOT)趨勢所發展出的藍芽技術，技術特點是使用很低的能源消耗點對點的傳輸少量的資料，一般用在運動追蹤裝置、智能手錶、健康追蹤、家庭自動化…等等，低功耗藍芽一般分為兩種裝置: Peripheral Device(外圍裝置): 一般為智慧型穿戴裝置 Central Device(中心裝置): 一般是智慧型手機，一般為訊號的接收方 低功耗藍牙工作原理外圍裝置在未被連接時會不斷對外廣播(Advertisements), 中心裝置在接收到廣播內容後可以自行決定要不要連接 What is BLE? (2020) | Bluetooth Low Energy | Learn Technology in 5 Minutes 什麼是 Beacon利用 ble 外圍裝置的廣播特性，廣播特定格式訊息的低功耗藍芽裝置，可以讓中心裝置在聽到此種廣播訊息時執行相對應指令，ex: 推播廣告，跳出資訊彈窗等，目前市場主流的 Beacon 協議有 iBeacon(Apple), Eddystone(Google), AltBeacon(Open Source), 三者中最熱門的則是 iBeacon Beacon 使用案例 關於 iBeaconiBeacon 為 Apple 在 2013 WWDC 上發布的 BLE 的應用技術，其將 BLE 廣播資料格式定為 範例： 同一家公司使用一個UUID，依照城市不同用不同的Major value，依照商品不同用不同的Minor Value 名詞解釋 Region: Apple 將 beacon 信號範圍認定為一個 Geofence（虛擬的地理圍欄或區塊）, 由上述的 uuid, major, minor 和 identifier (這個 region 的名稱 ex: 2 樓辦公室)來定義, 定義 uuid 和 identifier 是必填，major 和 minor 可以依照需求選填, 一個 App 最多一次同時偵測 20 個 Region Ranging: 裝置在偵測與 beacon 距離的行為，只能在 App 前景使用 觸發 eventName: didRangeBeacons 所需權限：Location When In Use Usage Monitoring: 監測手機是否進到 Region 或離開 Region，能在前景、背景、未打開 App 的情境下使用 觸發 eventName: didEnterRegion, didExitRegion 所需權限：Location Always Usage 注意：iOS 預設背景偵測只會有幾秒的時間來處理 Android 是否也支援 iBeacon是的，iBeacon 只是一種 BLE 廣播的資料格式，Android 可以偵測此格式的資料後，讓 App 做對應處理，目前已有 Android Library 讓 Android 可以像 iOS 一樣進行 Ranging 和 Monitoring Android 需要地點權限來偵測 beacon, 若未開啟會掃不到 新增以下 permission 在 AndroidManifest.xml // old version of Android&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;// SDK 29+&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_BACKGROUND_LOCATION\" /&gt; React-Native 相關的套件react-native-beacons-manager 是維護年份相對較近的套件，但目前已經 3 年左右沒有再發布新版本，目前是使用 github 上最新的 git commit 點來做安裝 \"devDependencies\": { \"react-native-beacons-manager\": \"git://github.com/MacKentoch/react-native-beacons-manager.git#d118c87\", }, 目前實測當 App 在前景時 Ranging 和 Monitoring 都能夠正常運作 參考文件與影片藍芽 你不了解的『藍芽』，硬核無線技術(上) 你不了解的『藍芽』，硬核無線技術(下) 淺談 BLE（Bluetooth Low Energy低功耗藍牙）Android、iOS 概述 GATT 藍芽傳輸 Beacon Get Started with Beacon(Android Official Document) How Beacon works? iBeacon. It’s a Trademark, Not a Technology. ESP32 #6: BLE / Bluetooth iBeacon implementation Understanding the different types of BLE Beacons Turning an iOS Device into an iBeacon Device How to scan iBeacon signals without specifying UUID? ibeacon背景偵測流程 Swift iBeacon App 程式設計 iBeacon 偵測範例 - android client estimote api doc (此 Doc 非常解釋清楚 ，請優先閱讀) iBeacon Apple Docs Getting Started with iBeacon (此為 Apple 完整說明 iBeacon 運作方式文件，請優先閱讀) Determining the Proximity to an iBeacon Device Region Monitoring and iBeacon Ranging for Beacons FAQ 可以改 Beacon 的 UUID 嗎？ 可以，但是需要經由廠商提供的 App 或 SDK Question reference: Stack Overflow , Apple Developer Forums","link":"/2021/09/29/React-Native-Beacon-%E5%8A%9F%E8%83%BD%E9%96%8B%E7%99%BC/"},{"title":"如何在 React Native 專案新增 iOS Widgets","text":"React Native 專案設定新增 widget extension 之後，專案會發生無法 build 的錯誤, 請參考此 issue: https://github.com/facebook/react-native/issues/29246 調整 swift 版本 調整完後請新增一個 swift 檔，Xcode 會詢問你是否要加入 bridge-header 檔來讓 Objective-c 的程式可以讀 swift 的程式，新增完成後，專案就可以正常 compile 了 Widget 工作原理Widget 依照 TimelineProvider 提供的 Snapshot/Placeholder 和 Timeline 進行顯示與更新，只要 Timeline 更新，Widget 就會更新 預設顯示畫面 (Snapshot/Placeholder)工具列選擇 Widget 時，預設的 Widget 顯示資 Timeline entries(entry[]): 每時間點需要顯示的資料 entry: 由 顯示時間（date）和其他自定義資料組成 Policy: 更新 Timeline 的規則 Policy 種類： atEnd: 當 TimelineProvider 提供 TimelineEntry 為陣列的最後一個時，系統將會要求新的 Timeline。 after(Date): 當指定的時間到，取得新的 Timeline never: 不再抓取，但可以在 App 開啟時主動 reload Timeline 使用 atEnd policy 的 Timeline 使用 after policy 的 Timeline 在 App 裡更新 Timeline 更新一個 Widget 的 Timeline WidgetCenter.shared.reloadTimelines(ofKind: \"com.brian.MyApp.My-Widget\") 更新所有 Widget 的 Timeline WidgetCenter.shared.reloadAllTimelines() Widget 如何與 App 共享資料AppGroup在 App Traget 下面選擇 AppGroup, 如果沒有建立過，點擊下面 + 號即可建立 重複上面動作，將 Widget 也加到相同名稱的 AppGroup, 我們就可以讀取、存取 UserDefault 裡面的資料 let userDefaults = UserDefaults(suiteName: \"group.widget.store\");userDefaults?.setValue(value, forKey: \"text\" ) let userDefault = UserDefaults(suiteName: \"group.widget.store\")let text = userDefault?.value(forKey: \"text\") as? String ?? \"No text!!\" 點擊 Widget 後導頁至特定頁面 （Deep Linking）建立 App urlType React Navgation 設定在 iOS 專案裡的 AppDelegate.m 加入 // Add the header at the top of the file:#import &lt;React/RCTLinkingManager.h&gt;// Add this above the `@end`:- (BOOL)application:(UIApplication *)app openURL:(NSURL *)url options:(NSDictionary&lt;UIApplicationOpenURLOptionsKey,id&gt; *)options{ return [RCTLinkingManager application:app openURL:url options:options];} 設定 Deeplink prefix const SimpleApp = createAppContainer( createStackNavigator({ Home: { screen: HomeScreen }, Chat: { screen: ChatScreen, // :user 是 navigation 的參數 path: 'chat/:user', }, );const prefix = 'mychat://';const MainApp = () =&gt; &lt;SimpleApp uriPrefix={prefix} /&gt;; 設定點擊 Widget 的 url var body: some View { VStack { // 到 Chat screen 的按鈕 Link(destination: homeDeepLink) { Text(\"mychat://Chat/abc123\") } }.widgetURL(\"mychat://Home\") // 點擊 Widget 外框} Reference Article: 初探 Widget Extension in iOS 14 讓不同 App 共享資料的 App Group WidgetKit(Official Doc) Perform a deeplink from SwiftUI widget on tap React Navigation Deep Link React Native bridge Swift Reference Video : Create SwiftUI Widgets in iOS 14 (Xcode 12, Swift, 2020) - iOS Development","link":"/2021/10/01/%E5%A6%82%E4%BD%95%E5%9C%A8-React-Native-%E5%B0%88%E6%A1%88%E6%96%B0%E5%A2%9E-iOS-Widgets/"},{"title":"Express 筆記","text":"Express ConceptExpress is a bunch of middlewares works together Expresss Basic Routingconst express = require('express');const app = express();app.get('/register', (req, res) =&gt; { const body = req.body; const isSucceed = auth(body); if (isSucceed) { res.send('Register Successfully'); } else { res.status(443).sene('Authentication fail, unable to register'); }}); Apply Middlewareconst express = require('express')const app = express()function validateUser(req, res, next) { res.locals.validated = true; next()}// Apply the middleware to all method at route '/'app.use('/' ,validateUser)// Apply the middleware to \"GET\" method at route '/'app.get('/', validateUser)app.listen(3000) Use the built-in middleware express.json() : 解析 conten-type 是 application/json 的 request express.urlencoded() : 解析 conten-type 是 application/x-www-form-urlencoded 的 request , 最常見 POST 提交數據的方式，瀏覽器的原生 表單，如果沒有設置 enctype 屬性，就會以默認以此方式提交數據 POST &lt;http://www.example.com&gt; HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 通過使用以上內件的 middleware, 我們就可以在 res.body 得到前端 POST 過來的資料 const express = require('express')const app = express()app.use(express.json())app.use(express.urlencoding())app.post('/', (req, res, next) =&gt; { const data = res.body res.send('&lt;h1&gt;I got the data&lt;/h1&gt;')}) Servering static content express.static: serving specified folder const express = require('express')const app = express()// express.staic 也是內建的 middlewareapp.use(express.static('public')) 使用 helmet 增加 server 安全性express 文件 使用 Helemt npm install --save helmet Using View engine熱門的 view engine 選項有 pug handlebars: npm i hbs mustache ejs 使用前要用 npm 安裝 npm install pug --save const express = require('express')const app = express()// 告知 express, 我們要使用 pug 做 view engineapp.set('view engine', 'pug');// 可以設定 view template 放在哪個檔案夾 , 預設會去讀同一層目錄的 views 檔案夾// app.set('views', path.join(__dirname, 'views'))app.get('/', (res, res) =&gt; { res.render('index')}) 傳值到 view template 裡const express = require('express')const app = express()// 告知 express, 我們要使用 pug 做 view engineapp.set('view engine', 'pug');app.get('/', (res, res) =&gt; { // 後面的參數其實都被放到 res.locals 裡面了 res.render('index', { title: 'Hey', message: 'Hello there!'});}) html head title= title body h1= message Handle cookiessetCookiesapp.post('/proccess_login', (req, res, next) =&gt; { const userName = req.body.userName; const password = req.body.password; if (password === correctPassword) { res.cookie('userName', userName); res.redirect('/welcome') } else { res.redirect('/login?msg=fail') }}) parseCookiesInstall cookie-parser npm install cookie-parser Apply cookie-parser as middleware var express = require('express')var cookieParser = require('cookie-parser')var app = express()app.use(cookieParser())app.get('/', function (req, res) { // Cookies that have not been signed console.log('Cookies: ', req.cookies) // Cookies that have been signed console.log('Signed Cookies: ', req.signedCookies)})app.listen(8080) 設定 Cookie 案例我們平常在用 express 時都是回傳 JSON 格式，所以 express 會直接幫我們在 header 帶入 Content-Type: 'application/json' 但是如果我們今天要回傳圖片，我們就可以設定 Content-Type 為 image/jpg 格式 舉例，今天使用者要取的自己的大頭貼圖片 app.get('/user/me/avatar', auth, (req, res) =&gt; { res.set('Content-Type', 'image/jpg'); // user 物件裡的 avatar 屬性是的 base64 圖片資料 res.send(req.user.avatar)}) Handle Cookie and Session在做用戶驗證時，常用的驗證方式之一是 Session Based 的驗證方式，簡單來說就是當用戶登入成功後，我們在將一些驗證成功的資料放在入 cookie 讓之後的 client 的 request 都帶著這個 cookie 來讓 server 進行辨識，其中有兩種做法 將用戶資訊加密後放入 cookie 中, 可使用 cookie-session 套件來完成 在 server 產生 session id，cookie 中只帶 session id, 用戶資料會存在另一個 Server 端的 DB (Redis), 每次 request 透過 session id 來辨識使用者，可以用 express-session 套件完成 Pass data from URLQuery string假設前端 request url 為: https://{your_domain_name}/product?productId=abc13&amp;productStatus=onSell app.get('/product', (req, res, next) =&gt; { const query = req.query; const productId = query.productId; const productStatus = query.productStatus;}) 在 redirect 時加入 params app.post('/proccess_login', (req, res, next) =&gt; { const userName = req.body.userName; const password = req.body.password; if (password === correctPassword) { res.cookie('userName', userName); res.redirect('/welcome') } else { res.redirect('/login?msg=fail') }}) WildCards假設前端 request url 為: https://{your_domain_name}/abc123/onSell app.get('/product/:productId/:productStatus:', (req, res, next) =&gt; { const productId = req.params.productId; const productStatus = req.params.productStatus;}) Pagination(分頁）透過 Query String 給 API 要 filter 的條件 GET /task?completed=true 只要取得完成的 task GET /task?limit=10&amp;skip=10 只拿 10 筆，並且跳過前十筆 router.ger('/tasks', auth, async (req, res) =&gt; { const query = req.query}) Download filesapp.get('/statement', (req, res, next) =&gt; { // res.download 第二個參數可以改下載檔案的名稱 res.download(path.join(__dirname, 'userStatements/BankStatement.png'))}) express 其實只是把 header 改掉，然後呼叫 res.sendFile() 如果你只要將 header 的 content-disposition 改為 attchment 可以改用 res.attachment() app.get('/statement', (req, res, next) =&gt; { res.attachment(path.join(__dirname, 'userStatements/BankStatement.png'))}) 檔案下載錯誤處裡, 通常錯誤發生時 response 可能已經回了，所以不能在 callback 裡面再重新送一次, 可以利用 res.headersSent 檢查 header 是否已送出 app.get('/statement', (req, res, next) =&gt; { // res.download 第二個參數可以改下載檔案的名稱 res.download( path.join(__dirname, 'userStatements/BankStatement.png'), 'BrianStatement', (error) =&gt; { if (error) { // res.headersSent is a bool, true if headers are already sent if (！res.headersSent) { res.redirect('/download/error') } } } )}) Routerexpress 提供，用來拆分 route 的 middleware const express = require('express');const { User } = require(\"../models\");const router = express.Router();// Create userrouter.post('/users', async (req, res) =&gt; { const user = new User(req.body); try { const savedUser = await user.save() res.status(201).send(savedUser); } catch (e) { res.status(400).send(e); }}) 向 express 註冊 Router const express = require('express')const app = exprss()const userRouter = require('./routes/userRouter')app.use(userRouter) Handle Http headers in ExpressSet headerapp.get('/', (req, res, next) =&gt; { const date = new Date(1969, 6, 20) res.set('Date', date) res.set('Context-Type', 'text/plain')}) Uploading files to Express with Multer上傳圖片的格式是 multipart/form-data 可以用 multer 來 parse 檔案 假設我們有一個 form 可以上傳檔案 &lt;html&gt; &lt;form method='post' action='formsub' enctype='multipart/form-data'&gt; &lt;input type='file' name=\"meme\" /&gt; &lt;/form&gt;&lt;/html&gt; 上傳單個檔案，檔案名稱需為 meme const express = require('express')const multer = require('multer')const app = express()const upload = multer({ dest: 'public/images/uploads',});app.post('/formsub', upload.single('meme'),(req, res, next) =&gt; { const fileData = req.file;}) 限制 Upload 大小、檔案類型使用 limits option 去限制上傳檔案大小 const app = express();const multer = require('multer');const upload = multer({ dest: 'images', limits: { // 1 million bytes fileSize: 1000000, }});app.post('/upload', upload.single('upload'), (req, res) =&gt; { res.send();}); 使用 fileFilter option multer 提供三個參數給你用 fileFilter(req, file, cb) 第三個 cb 參數比較特別， 如果你接收這個檔案: cb(null, true) 如果你拒絕接收這個檔案： cb(null, false) 如果你想 throw 錯誤給 client： cb(new Error('給 client 的錯誤')) const app = express();const multer = require('multer');const upload = multer({ dest: 'images', limits: { // 1 million bytes fileSize: 1000000 }, fileFilter(req, file, cb) { if (!file.originalname.endsWith('.pdf')) { return cb(new Error('Please upload a PDF')) } cb(null, true); }}); 使用 storage option 將設定為 memoryStorage 這個選項會存在記憶體中的選項轉為 Buffer 格式，可以透過 req.file.buffer 取得檔案 buffer const storage = multer.memoryStorage()const upload = multer({ storage: storage })const upload = multer({ fileFilter(req, file, cb) { if (!file.originalname.endsWith('.pdf')) { return cb(new Error('Please upload a PDF')) } cb(null, true); }, storage});router.post('/users/me/avatar', auth, upload.single('avatar'), async (req, res) =&gt; { req.user.avatar = req.file.buffer; await req.user.save(); res.send('ok');}) Handling Express Errors如果前面 middleware 丟出錯誤，我們可以新增 Error Handling Middleware Error Handling Middleware, 與一般 middleware 的差別是 只有在 call signature 都是四個參數的的情況下，express 才會認定這是 error handling middleware,並且 call 這個 function 以下例子，我們先加上一個直接丟錯誤的 middleware 在 route handler 的前面, 後面加上再加上Error Handling Middleware const errorMiddleware = (req, res, next) =&gt; { throw new Error('From my middleware');}app.post('/upload', errorMiddleware, (req, res) =&gt; { res.send('ok')}, (err, req, res, next) =&gt; { res.status(500).send({ error: error.message })}) 當實際執行可以發現當 error 被 throw 後 ，route handler 被跳過了，直接執行 Error Handling Middleware 其他細節和用法可以參考 express 文件: 錯誤處理","link":"/2021/10/05/Express-%E7%AD%86%E8%A8%98/"},{"title":"使用 apollo-studio 與 express-session 無法 set-cookie 問題","text":"Apollo Server 3 後，將 graphql-playground 改為自家的 apollo-studio, 當你一開啟 http://localhost:{YOUR_DEV_PORT} 時，它會主動導頁到 https://studio.apollographql.com 一開始用的時候，覺得特別好用，apollo-studio 的 auto-complete 的功能比 graphql-playground 好用許多，但是做到登入的功能時遇到這個問題困擾我超久，明明就有給 set-cookie 的 header，但是怎麼樣都拿不到 cookie 問題apollo-studio 為 https, cookie 裡面必須要有 SameSite=None; Secure 並且將 resonse header 加入以下兩個選項才能 set-cookie 成功 Access-Control-Allow-Origin: https://studio.apollographql.comAccess-Control-Allow-Credentials: true 如果 set-cookie 裡沒有 SameSite=None; Secure 即便 res 的 header 有 set-cookie 也會被 chrome 直接略過 我們可以用以下程式，將 SameSite=None; Secure 加入 cookie res.cookie('testCookie', 'haha', { sameSite: 'none', secure: true }) 但是 express-session 的 cookie 選項 secure 選項必須要是 https 開啟的狀態它才會將 secure 加到 cookie 裡，原碼裡面有特別寫 function 去驗證是否為 https 連線，如果secure 選項給 true 但卻非 https 連線，它就會直接不 setCookie express-session 源碼 function issecure(req, trustProxy) { // socket is https server if (req.connection &amp;&amp; req.connection.encrypted) { return true; } // do not trust proxy if (trustProxy === false) { return false; } // no explicit trust; try req.secure from express if (trustProxy !== true) { return req.secure === true } // read the proto from x-forwarded-proto header var header = req.headers['x-forwarded-proto'] || ''; var index = header.indexOf(','); var proto = index !== -1 ? header.substr(0, index).toLowerCase().trim() : header.toLowerCase().trim() return proto === 'https';} onHeaders(res, function(){ if (!req.session) { debug('no session'); return; } if (!shouldSetCookie(req)) { return; } // only send secure cookies via https if (req.session.cookie.secure &amp;&amp; !issecure(req, trustProxy)) { debug('not secured'); return; } if (!touched) { // touch session req.session.touch() touched = true } console.log(req.session.cookie.data) // set cookie setcookie(res, name, req.sessionID, secrets[0], req.session.cookie.data); }); 解法一使用 ApolloServerPluginLandingPageGraphQLPlayground plugin，用舊版 apollo-server 內建 graphql 提供的 playground，跑在 local 端就不會遇到以上問題 import { ApolloServer } from 'apollo-server-express'import { ApolloServerPluginLandingPageGraphQLPlayground } from 'apollo-server-core'import express from 'express'const app = express()app.use( session({ name: 'qid', store: new RedisStore({ client: redisClient, disableTouch: true }), cookie: { maxAge: 1000 * 60 * 60 * 24 * 5, // 5 days httpOnly: true, sameSite: 'lax', secure: __prod__ }, secret: 'wefjlewf', resave: false, saveUninitialized: false // do not create empty session by default }))const apolloServer = new ApolloServer({ schema: await buildSchema({ resolvers: [PostResolver, UserResolver] }), context: ({ req, res }) =&gt; ({ em: orm.em, req, res }), plugins: [ ApolloServerPluginLandingPageGraphQLPlayground() ]}) 解法二用 patch-package 新增 patch, 將判斷是否為 https 連線的地方新增是否為 production 環境 const isProduction = process.env.NODE_ENV === 'production'if ( req.session.cookie.secure &amp;&amp; isProduction &amp;&amp; !issecure(req, trustProxy)) { debug('not secured'); return;} 但需注意，若要部署到的 heroku 上面的話要新增設定，請參考文件 GitHub - ds300/patch-package: Fix broken node modules instantly 🏃🏽‍♀️💨","link":"/2021/10/06/%E4%BD%BF%E7%94%A8-apollo-studio-%E8%88%87-express-session-%E7%84%A1%E6%B3%95-setCookie-%E5%95%8F%E9%A1%8C/"},{"title":"你真的懂 Node.js 裡 Libuv 如何使用 Thread Pool 嗎？","text":"不廢話先上題，請問以下程式 conosole.log 的順序？ const https = require('https');const crypto = require('crypto');const fs = require('fs');const start = Date.now();function doRequest() { https .request('https://www.google.com', res =&gt; { res.on('data', () =&gt; {}) res.on('end', () =&gt; { console.log('Request:', Date.now() - start); }) }) .end();}function doHash() { crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () =&gt; { console.log('Hash:', Date.now() - start); })}doRequest();fs.readFile('text.txt', 'utf8', () =&gt; { console.log('FS:', Date.now() - start);})doHash();doHash();doHash();doHash(); 執行結果 為什麼會有此結果？第一個點我需要了解到 node 底層使用了 Libuv 處理檔案讀寫和計算 hash 等功能，Libuv 用了Thread Pool 中的 Thread 來處理這些任務，Thread Pool 預設的 Thread 數量為 4 個，換句話說只有 4 個 Libuv 負責的任務可以同時進行，然後 https 請求不是由 Libuv 負責，而是 OS 負責，OS 會決定是否開一條新的 Thread 來處理此任務，因此我們就看到了 HTTPS 請求最快完成，但是問題來了，為什麼 fs module 檔案讀了這麼久？ 那我們需要先了解讀檔案的流程 上圖我們可以看到， node 沒有直接發 request 去讀檔案，而是在第二步時，先取得該檔案的狀態資訊，才後才在第四步發 request 去讀檔案 我們來看執行的方式 一開始 fs, PBKDF2 1 ～ 3 號就將 Thread Pool 直接佔滿了，然後 Thread #1 發了 Request 去取得該檔案的狀態 但是，Thread #1 發現要等硬碟將檔案狀態返回不知道要等多久，所以等的期間就不繼續執行 FS 的任務了，就讓 FS 任務等一下吧 所以這時 Thread #1 手上沒有任務了，PBKDF2 #4 的任務就被分配給 Thread 1# 執行了 最終 Thread #2, #3, #4 其中一個 Thread 會結束工作，我們假設 Thread #2 做完 PBKDF2 #1，就把 FS 的任務拿過來繼續做了，我記得我們剛剛講到 node 讀取檔案的步驟嗎？Node 會先 Request 要檔案的資訊，再發 Request 讀取檔案的內容，所以理論上 Thread #2 也會遇到一個將 Request 發給硬碟後的空窗期，但後面已經沒有任務了所以它就空著繼續等 這就是為什麼我們會在執行給果看到先 Hash 先完成，FS 會在後一個完成 驗收：那如果我們將 Hash 減少到兩個，結果會是如何呢？ 現在每個任務都有一個 Thread 去執行了，FS 反而變最快了","link":"/2021/10/18/%E4%BD%A0%E7%9C%9F%E6%87%82-Node-js-%E8%A3%A1-Libuv-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Thread-Pool%E5%97%8E%EF%BC%9F/"},{"title":"Node.js 效能提升","text":"在什麼樣的情況下需要效能提升？如果我們的程式需要進行重度的計算，而且這個任務無法像 timer, http request 等，可以非同步運行時，我們的 Request 就會被卡住 ex: const express = require('express');const app = express();function doWork(duration) { const start = Date.now(); while(Date.now() - start &lt; duration) {}}app.get('/', (req, res) =&gt; { doWork(5000) res.send('&lt;h1&gt;Hi There!&lt;/h1&gt;');});app.listen(3000, () =&gt; {}); 我們寫一個 doWork function，讓它在既定秒數內不斷跑 while 迴圈 這個時如果開兩個 tab 載入頁面，你就會發現第二個載入的頁面會慢非常多，因為 server 還在處理第一個頁面，必須等第一個頁面處理完才會處理第二個頁面 利用 Node.js “Cluster” Mode 多開幾個 process 來幫忙吧！因為每個 Process 都只能用單核心 CPU 來運行， 透過 Cluster 模組就可以開更多的 Process 來幫忙處理，而這個Cluster的模組強大的地方在於讓我們只監聽一個Port，加上Master/Worker的概念，當收到請求後就分配給底下的Worker進行處理。 Cluster Manager 負責監控底下 Node Server 的狀態，Cluster Manager 可以開 Node Instance, 關閉 Instance, 送資訊給 Instance Cluster 如何運作？他主要是使用 child_process.fork() 產生新的 proccess 用此來與 master_process 溝通。 如圖所示 圖片來源: 【我可以你也可以的Node.js】第二十篇 - Node Cluster 讓你的 Thread 不再孤軍奮戰 預設配發方式當一個請求進來的時候進到 master process 然後由他去輪流指派 一個 process 。 使用 Cluster使用 Cluster 時，我們可以使用 cluster.isMaster 屬性去判斷現在是否為 Master Process const cluster = require('cluster');const express = require('express');if (cluster.isMaster) { // Create child processes // Cause index.js to be executed again but in child mod cluster.fork(); cluster.fork();} else { const app = express(); function doWork(duration) { const start = Date.now(); while(Date.now() - start &lt; duration) {} } app.get('/', (req, res) =&gt; { doWork(5000) res.send('&lt;h1&gt;Hi There!&lt;/h1&gt;'); }); app.get('/fast', (req, res) =&gt; { res.send('fast'); }) app.listen(3000, () =&gt; { console.log('server listening at port 3000') });} 我們新增一個不會阻塞的 route /fast ，由於我們現在有兩個 process 了，所以當我們開兩個 tab，一個發到 / ，另一個再發到 /fast ，我們可以發現 /fast 直接就返回了，沒有被上個 Request 卡死 既然開 Process 就可以變快，那開好開滿不就超快?我們這邊可以用 ab (apache-benchmark) 指令來測試開越多 child process 是否就越好 ab -c 50 -n 500 localhost:3000/fast -c : concurrency 的意思, -c 50 同時保持有 50 Request 還處 pending 的狀態 -n : request 的總數, -n 500 代表總共發 500 個 測試方式：逐步增加 Child Process 和 Request 測試程式: if (cluster.isMaster) { // 逐步增加 cluster.fork();} else { const app = express(); app.get('/', (req, res) =&gt; { crypto.pbkdf2('a', 'b', 100000, 512, 'sha512', () =&gt; { res.send('&lt;h1&gt;Hi There!&lt;/h1&gt;'); }) }); app.listen(3000, () =&gt; { console.log('server listening at port 3000') });} 測試 1 個 Child Process測試指令 ab -c -1 -n -1 localhost:3000/ 測試結果 測試 2 個 Child Process測試指令 ab -c -2 -n -2 localhost:3000/ 測試結果 測試 10 個 Child Process測試指令 ab -c -10 -n -10 localhost:3000/ 測試結果 測試 2 個 Child Process 同時處理 10 個 Request測試指令 ab -c -10 -n -10 localhost:3000/ 測試結果 我們可以看到，新增一個 Child Process，確實是讓 2 個請求維持在同一時間返回，但是新增到10 個 Child Process 時，面對同時 10 個請求速度卻下降了，然會後最驚人的事，只開兩個 Child Process 卻比開 10 個的快？？？ Stack Overflow 也有人提出相似問題: Node.js clustering is slower than single threaded mode， 但看起也有沒有結論 PM2相較與直接用 cluster 模組，在管理 process 方面，社群大多數人會使用 pm2 開源專案，pm2 除了管裡 process 以外還有許多實用的功能，可以參考 Ray Leel 大的 好 pm2, 不用嗎？ 安裝:npm i -g pm2 使用方法：開啟 instance: -i 後面接希望啟動 instance 的數量， 0 或 max 默認自動偵測 CPU 啟動最大值 pm2 start app.js -i 0 顯示管理程序狀態: pm2 [list|ls|status] 停止服務： pm2 stop app_name 停止並刪除服務: pm2 delete app_name Reference: 【我可以你也可以的Node.js】第二十篇 - Node Cluster 讓你的 Thread 不再孤軍奮戰","link":"/2021/10/20/Node-js-%E6%95%88%E8%83%BD%E6%8F%90%E5%8D%87/"},{"title":"使用 stream 上傳檔案到 Server","text":"有時候檔案太大，沒有辦法一次整個上傳，比如說影片、圖片等，這時候我們就需要將檔案拆成一小塊一小塊的 bytes 上傳 實作流程： 使用者上傳檔案 用 FileReader 讀取檔案內容 將檔案拆成一小塊一小塊後上傳 後端收到每一小塊資料後 append 到該檔案裡 前端的畫面，使用者先點選“選擇檔案”上傳檔案後，在點擊右邊的 “讀取＆上傳”將檔案上傳到 Server Client 部分&lt;body&gt; &lt;h1&gt;My file uploader&lt;/h1&gt; File: &lt;input type=\"file\" id='f'&gt; &lt;button id=\"btnUpload\"&gt;Read &amp; Upload&lt;/button&gt; &lt;div id=\"divOutput\"&gt;&lt;/div&gt; &lt;script&gt; const btnUpload = document.getElementById(\"btnUpload\") const divOutput = document.getElementById('divOutput') const f = document.getElementById('f') btnUpload.addEventListener(\"click\", () =&gt; { const theFile = f.files[0]; const fileReader = new FileReader() fileReader.onload = async (e) =&gt; { const CHUNK_SIZE = 100000 // 100 kb const chunkCount = Math.ceil(e.target.result.byteLength/CHUNK_SIZE) const fileName = encodeURIComponent(Math.random() * 1000 + theFile.name) for (let chunkId = 0; chunkId &lt; chunkCount + 1; chunkId++) { const chunk = e.target.result.slice( chunkId * CHUNK_SIZE, chunkId * CHUNK_SIZE + CHUNK_SIZE ) await fetch (\"http://localhost:8080/upload\", { \"method\": \"POST\", \"headers\": { \"content-type\": \"application/octet-stream\", \"content-length\": chunk.length, \"file-name\": fileName }, \"body\": chunk }) const completePercentage = Math.floor(chunkId * 100 / chunkCount) divOutput.textContent = `${completePercentage} %` } } fileReader.readAsArrayBuffer(theFile) }) &lt;/script&gt;&lt;/body&gt; html 的結構 我們使用 FileReader 讀取使用者上傳的檔案，FileReader 讀到的資料存為 ArrayBuffer，基本上就是 bytes array, 然後我們用 slice 將這些 bytes 拆分為一塊一塊的 chunk (瀏覽有限制每個 Request 最高 100,000 bytes， 就是 100 kb)，依序將每個 Chunk 上傳，我們也可以透過目前已上傳多少 Chunk 來計算上傳進度 Header 的 content-type 需要為 application/octet-stream 因為我們要上傳二進制的資料 注意：檔案名稱需要與 encodeUROComponent 轉為 Base64, 到後端再 decode 回來，因為傳送中文檔名會發生錯誤: Request请求：Failed to execute ‘setRequestHeader’ on ‘XMLHttpRequest’: String contains non ISO-8859-1 code point. Server 部分const fs = require('fs')const http = require('http')const httpServer = http.createServer()httpServer.on(\"listening\", () =&gt; \"Listening\")httpServer.on(\"request\", (req, res) =&gt; { if (req.url === '/') { const file = fs.readFileSync('./index.html') res.end(file) return } if (req.url === '/upload') { const fileName = decodeURIComponent(req.headers[\"file-name\"]) req.on(\"data\", (chunk) =&gt; { fs.appendFileSync(fileName, chunk) console.log(`received chunk! ${chunk.length}`) }) res.end(\"uploaded\") }})httpServer.listen(8080) Server 拿到資料後 append 到該檔案即可 測試上傳進度顯示正確 我們的資料夾也確實收到檔案","link":"/2021/10/28/%E4%BD%BF%E7%94%A8-stream-%E4%B8%8A%E5%82%B3%E6%AA%94%E6%A1%88%E5%88%B0-Server/"},{"title":"我們為什麼需要 TLS 證書？","text":"想要了解我們為什麼需要 TLS 證書前，我們必須先了解，對稱加密與非對稱加密是什麼 對稱加密 (Symmetric Encryption) 雙方使用同一把密鑰加密、解密 優點：速度快，加密效率高，通常在訊息傳送方需要加密大量資料時使用 缺點： 萬一密鑰被偷，丟失，加密的資料就不再安全 一個網站有幾千萬個用戶，每個用戶都要採用不同的密鑰，導致密鑰難以管理、容易洩漏 非對稱加密 (Asymmetric Encryption) 非對稱加密有兩種鑰匙，公鑰 (public key) 和私鑰（secret key)，公鑰對外公開，私鑰放在服務器，客戶端用公鑰加密資料，資料傳送到服務器後用私鑰解密，當伺服器要傳送資料到客戶端時，用私鑰加密資料，客戶收到資料後用公鑰解密 優點： 密鑰更容易管理，服務器保管好私鑰就好 可以用做網站證書的簽名 就是網站用私鑰加密的，公鑰可以解開 舉例：當我們請求 google.com 的網頁時，我們要怎麼知道該網頁真的是 google 傳的呢？就是當我們可以用公鑰解開這個文檔的時候，因為只有 google 有私鑰可以加密這個文檔 缺點： 速度較慢 混合加密 (Hybrid cryptosystem)顧名思義，結合對稱與非對稱加密各自的優點的加密法 其核心目的是: 如何安全的讓客戶端與服務端拿到對稱加密的鑰匙 假設 Alice 想要安全的與 Bob 通信 Bob 先生成公、私鑰 Bob 將公鑰給 Alice Alice 生成一把對稱加密的鑰匙，叫做對談金鑰 (Session Key) Alice 用對談金鑰加密要傳送的內容 (使用對稱加密) Alice 用 Bob 給的公鑰加密對談金鑰 (使用非對稱加密） Alice 將 4,5 步的加密結果，一起傳給 Bob Bob 收到後用自己的私鑰解密對談密鑰 (使用非對稱解密） Bob 再拿對談密鑰解密傳送的內容 (使用對稱解密) 那為什麼還需要 TLS 證書？聽起來混合加密很安全呀，那幹嘛還要 TLS 證書呀？客官且慢，聽我娓娓道來這個可怕的攻擊手法假設我們要訪問 google.com 時，如果有個中間人在 google 服務器回傳公鑰的時候攔截了公鑰 中間人自己生成公、私鑰，我們叫它假公、私鑰 他將 google.com 的公鑰替換成假公鑰傳給我們 我們拿到假公鑰後，我們生成對談金鑰 我們不以為意的用了這把假公鑰加密了對話鑰匙然後傳給服務端 中間人拿到加密的對話鑰匙 中間人用假私鑰解開對話金鑰，成功拿到了我們的對話金鑰 中間人這時因為手上也有 google.com 一開始傳的公鑰，所以他也可以依照正常的混合加密方式，將自己的對話金鑰傳給 google.com，所以這樣一來這個中間人就同時有了我們對話金鑰和 google 對話金鑰，能夠在我們與 google.com 通信時，假裝是 google.com 回傳我們假資料或者假扮我們傳給 google.com 假資料，這就是一種 “中間人攻擊“。因此我們需要找一種方式去證明一開始 google 傳的公鑰就是 google 的，答案就是透過一個客戶端和服務端都相信的第三方，叫做憑證頒發機構(certificate authority 簡稱 CA)，簽發憑證給服務端 那怎麼簽發證書呢？服務器將自己的公鑰給 CA，CA 會用自己的私鑰加密這把公鑰稱為數位簽名 (Digital Signature)，然後連同原本的公鑰包在一起，稱為 CA 證書 那客戶端怎麼驗證 CA 證書?客戶端要與服務器通信時，先把 CA 證書回給客戶端，客戶端看證書上是某 CA 簽發的，就拿該 CA 的公鑰去解數字簽名，然後解出的值與證書上的公鑰相同，就代表公鑰確實是服務端的 Reference: https和密码学教程2：对称加密和非对称加密 對稱加密與非對稱加密優缺點詳解 What are SSL/TLS Certificates? Why do we Need them? and How do they Work? TTPS/SSL/TLS 概述，整體流程、憑證、數位簽章","link":"/2021/11/09/%E6%88%91%E5%80%91%E7%82%BA%E4%BB%80%E9%BA%BC%E9%9C%80%E8%A6%81-TLS-%E8%AD%89%E6%9B%B8%EF%BC%9F/"},{"title":"Database Index 是什麼？","text":"以下會以 PostgreSQL 為例 PostgreSQL 將 table 資料都存成一個一個的檔案，我們稱為 Heap 或 Heap files，Heap file 由多個 Block 組成，每個 Block 為 8KB，Block 裡面的 Item 或叫 Tuple ，就是一行一行的 Row 關係：Heap File &gt; Block &gt; Item 假設我們跑這個 Query SELECT * FROM users WHERE username = 'Rianna'; PostgreSQL 會從硬碟裡讀取整個 Head File 載入到記憶體，然後執行 Query ，一個一個找，直到最終找到 username 等於 Rianna，我們稱這樣的的查詢方式為 Full Table Scan，通常這樣會導致不好的效能 Index如果有個方法可以提前知道 Rianna 在哪個 Block，我們是不是可就只載入有 Rianna 在的 Block，就可以快速找到 Rianna 了，這就是 Index，可以想像 Index 就是書的章節目錄，告訴我們哪個章節從第幾頁開始 Index 主要為類型為 B-Tree 的結構，查找的時間為 O(log n) ，比原本的 O(n) 相比快多了 建立 index我們可以用各欄位建立 index 索引 用 username 建立 index CREATE INDEX ON users(username); 會用預設命名規則來命名 index, ex: users_username_idx 如果要為 Index 命名可以用： CREATE INDEX {YOUR_CUSTOM_NAME} ON users(username); 測試一下結果吧我們可以利用 EXPLAIN ANALYZE 語法來得到 Query 的時間 EXPLAIN ANALYZE SELECT * FROM usersWHERE username = 'Emil30' 我們使用一張約 5000 行 row 的 users table 做測試 沒有 index 加入 index 後 OMG! 竟然快 25 倍 自動產生的 IndexPostgreSQL 會對 Primary key 和 Unique Constraint 的欄位自動產生 Index 我使用的 database 的 GUI 工具是 TablePlus ，可以讓我看到該 table 的所有的 Index 如果是用 pgAdmin 的話，也可用 SQL 印出所有 Table 的 index SELECT relname, relkindFROM pg_classWHERE relkind = 'i'; Index 的缺點 需要額外的儲存空間：以剛剛 5000 個 user 的 table 來說，資料的大小是 880KB，index 則需 180KB，這個數字聽起來或許沒什麼感覺，但現在大家都會用 AWS, GCP 等雲端的服務，用戶數一多，每個月的金額也是非常驚人的 Insert 和 Update 的速度會變慢，因為 Insert 和 Update 時，需要同時更新 Index","link":"/2021/12/01/Database-%E6%95%88%E8%83%BD%E8%AA%BF%E6%A0%A1-%E4%B8%80-Index/"},{"title":"AWS VPC 筆記","text":"VPC 可以想成是一道牆，沒有你的同意外面的東西不能進牆內，同理裡面的東西不能出牆外，主要的設定有兩個 Region IP range: 用 CIDR 表示的的 IP 範圍 Subnet你可以在 VPC 切一個一個的 subnet 去放不同的資源，subnet 主要的用的在於更精細的調整資源的取用，比如我一個外對開放的 backend service 跑在 EC2 上，那我讀可以開一個 Subnet A 接受外部請求，但我的 DB 不想要可以被外部連接，我可以將另一個 subnet 來放我的 DB 創建一個 Subnet 要有 VPC AZ (Availablity Zone) IP range 被 AWS 保留的 IPAWS 會在每個 Subnet 保留 5 個 IP 做 networking 管理使用 假設 VPC 的的 IP 範圍是 10.0.0.0/22，所以總共有 1024 個 IP Address, 如果往下開 4 個 /24 IP 範圍的 subnet，每個 subnet 實際可以使用的 IP 數量是 1024/4 - 5 = 251 新手如果怕 IP 不夠用的話可以將 VPC 的 IP 範圍開為 /16 然後 Subnet 的 IP 範圍開為 /24 ，這樣就不怕 IP 數量不夠 Interent gatewayVPC 是一個隔離、獨立的環境所以要讓外面的請求可以進到 VPC，我們需要創建 Internet gateway，並且 Attach 到 VPC 上，可以把 Internet Gateway 想是家中的數據機(modem)，需要將電腦連上數據機才能上網 Virtual Private Gateway如果你只想要連本地或私人服務連到你的 AWS VPC，沒有要連接外網，可以使用 Virtual Private Gateway(VGW)，使用 VGW 後你就可以連接公司的內網服務到 AWS VPC，VGW 會使用 VPN 連線來確保安全性 Route Table外部 Request 透 IGW 進到了 VPC，但是他怎麼知道要到哪個房間(Subnet)，需要設定 Route Table Route Table 裡可以設定一系列的 Routes，用來決定 Network Traffic 要導向哪，Route 可以設定在 VPC 層級或 Subnet 層級 當你創建一個新的 VPC 時，AWS 會自動創建一個 Main Route Table，作用於整個 VPC，換句話說，在 VPC 內的服務可以自由的 Access 另一個 VPC 內的服務 Subnet 是否為 Public 也是依據 Route Table 的設定，如果 Subnet 和 IGW 之間有建立 Route 就代表這個 Subnet 是 Public Subnet 所以你需要為 Subnet 創建 Custom Route Table 來建立 Subnet 和 IGW 之間的 Route 第一個 Route 是創建 VPC 就創建的 Main Route Table: 讓 Traffic 可以進到 VPC 第二個 Route 建立該 Subnet 和 igw 間的 Route，讓 Traffic 可以倒到該 Subnet 創建 Custom Route TableVPC → Route Table 選擇 VPC 新增Subnet與 Internet Gateway 間的 Route 0.0.0.0/0 說明這個 Route 可以接受和傳送來自任何地方的 Traffic Target 下拉選單打 internet gateway，會就自動跳該 VPC 現有的 igw 給你選 綁定 Subnet 與 Route Table 選擇我們要綁定的 Subnet 設定 VPC 順序 (Cheatsheet) 創建 VPC 創建 Subnet 創建 Internet Gateway 創建 Custom Route Table Reference: VPC 和子網路","link":"/2021/12/16/AWS-VPC-%E7%AD%86%E8%A8%98/"},{"title":"AWS Fargate 入門","text":"1. 想想看如何在 EC2 上部署 Container如果我們想要使用 AWS EC2 來部署 Container 的話，我們可行的做法大概如下 創建一個 VPC 在 VPC 裡創建兩個以上的 public subnet，分別放到 2 個 Availability Zone 創建 EC2 instance template 並在 user data 裡為 EC2 instance 安裝 Docker 以後拉下程式的 Docker Image，然後運行 Container，一個 EC2 instance 會運行多個 Container 創建 EC2 Auto Scaling Group 和 Load Balancer 將流量導到這些 EC2 Instance 但是我們該如何在每個 EC2 Instance 裡放入這些 Container，我們會需要 container orchestration 來進行管理，也就是容器編排，這就談到我們今天的主角了 “AWS ECS”，以上流程建立出來的架構大概會是這樣 2. AWS Fargate看完上面的架構心都涼了，明明只想部署個 Container 怎麼這麼困難，這時候 AWS Fargate 來拯救你了，AWS Fargate 是一個服務讓你用 Serverless 的方式來使用 AWS ECS ，基本上它幫你把要管理 EC2 的任務拿走了，所以使用的架構圖就會變成這樣 你可以看到 Container 一樣分布在兩個 AZ 底下，Container 一樣被 ECS 管理，但是你看不到 EC2，因為 Fargate 已經這層抽象化了，這樣你就可以專注開發上了 使用 Fargate，你只需要定義 Container 運行時需要的東西就好： 你要用的 Docker Image 你要分配多少記憶體 你要幾顆 CPU Network: Container 要向外開哪個 port IAM 權限 2.1 相關名詞解釋在開始實作前我們有些專有名詞需要知道，這些專有名詞其實來自 ECS Cluster: 可以想成是一個界定的範圍內的 infrastructure 用來部署你的 Container，你可以在任何 VPC 下定義 Cluster，你可以選擇要將 Container 部署在哪些 subnet 底下，Fargate 會幫你管理 Cluster Service 和 Task: Service 將 Task 部署你到你的 Cluster 裡，Task 是一層用來運行 Container 的 Wrapper Container Definition: 用來定義 Container 一些執行時的相關設定，ex: image memory, port Task Definition: 也用來定義 Container 一些執行時的相關設定，ex: IAM 等 Service: 定義你要跑幾個 Container、、Load Balancer 一層一層向外設定 2.2 實作：用 Fargate 部署一個 Nginx Container到 ECS 頁面後選擇下 Get Started 定義 Container Definition 和 Task definition 選擇 Nginx 點 Next 就好，AWS 預設 Task Definition 名稱是 first-run-task-definition 定義 Service 一樣，不需要更改，直接下一步就好，預設的 Security Group 已經開啟 80 port 了 定義 Cluster 這邊我將 Cluster 名稱改成 nginx-test-cluster，方便等一下辨認 最後看一下沒問題就按下 Create 等 Task 的狀態變為 Running 後，我們就可以連到剛剛創建的 Nginx Container 了 將 Public IP 貼到瀏覽器就可以看到 Nginx 的 html 了","link":"/2021/12/17/AWS-Fargate-%E5%85%A5%E9%96%80/"},{"title":"建立 React Web 和 React Native 的 Monorepo","text":"使用 React Native 開發 APP 的一大好處就是可以與 React Web 共用程式，除了 UI, Routing 等無法共用以外，商業邏輯、hooks、utils、api 層處理，通通可以共用，要達到此目的我們可以使用 Monorepo，如果不知道 Monorepo 是什麼的可以參考 Fireship 的影片，概念上就是將所有的專案都放在同一個 repo 下達到方便共用的目的 Monorepos - How the Pros Scale Huge Software Projects // Turborepo vs Nx 1. 建立專案這我們要做的文件夾結構，各個專案放在 packages 的資料夾內，其中的 common 資料夾是放 app 與 web 共用的程式 ├── package.json└── packages ├── app ├── common └── web 1.1 建立文件夾與各專案cd 到 packages 目錄後，使用 CLI 工具建立各專案 APP 的部分使用 React Native CLI，這裡我們設定使用 TypeScript 的模板 npx react-native init app --template react-native-template-typescript Web 的部分使用 Create-React-App npx create-react-app web --template typescript 2. 設定 Yarn Workspace先移除各專案中的 node_modules rm -rf packages/*/node_modules/ 這理我們使用 Yarn Workspace 來建立 Monorepo，當然也可以使用其它的工具像是 Nx, Turborepo, Lerna 等，有機會之後試玩看看在寫文章與大家分享差別在哪 設定專案根目錄的 package.json，加上 private 為 true 和workspaces 屬性 { \"private\": true, \"name\": \"todo\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"workspaces\": { \"packages\": [\"packages/*\"], \"nohoist\": [\"**/react-native\", \"**/react-native/**\"] }} 根目錄的 package.json 其中比較特別的是 nohoist 屬性，因為 yarn workspaces 會將所有的 dependencies 都安裝在專案根目錄中的 node_modules 裡，來避免底下的專案安裝同樣的包，來達到共享依賴包的機制，yarn 在 packages 的專案裡的 node_modules 會創建 symlinks (軟鏈結)，來讓專案可以找到需要的依賴包 但是 react-native 所使用的 metro bundler 沒有支援 symlinks 的功能，所以 react-native 專案需要的套件必須在 app 目錄裡的 node_moudles 裡，metro 在打包時才找得到 3. 設定共用專案在 packages 目錄新增一個 common 資料夾，然後使用 npm init -y 來新增一個 npm 模組，更改 package.json 來調整套件名稱，方便之後在 app 或 web 的專案裡辨識 如果要用 TypeScript 的話，記得將 package.json 裡的 main 屬性改為 index.ts，這會設定這個專案的主要檔案為 index.ts { \"name\": \"&lt;你的專案名稱&gt;/common\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.ts\", &lt;-- 如果有用 TypeScript 的話，記得改這裡 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\"} common 的 package.json 然後試著新增一個 index.ts，export 一個 function 方便我們測試 export function testFunction () { console.log('test function fire');} index.ts 4. 使用共用專案在 app 的 pacakge.json 中新增共用依賴包 \"dependencies\": { \"react\": \"17.0.2\", \"react-native\": \"0.68.1\", + \"&lt;你的專案&gt;/common\": \"1.0.0\" }, 然後跑一次 yarn 指令來安裝依賴包 到這裡我們還不能使用 common 包裡的程式，我們需要設定 metro 來讀取根目錄的 node_modules，因為我們的 common 包會被放在那 const path = require('path');module.exports = { transformer: { getTransformOptions: async () =&gt; ({ transform: { experimentalImportSupport: true, inlineRequires: true, }, }), }, resolver: { extraNodeModules: { 'node_modules': path.resolve(__dirname, '..', '..') } }, watchFolders: [ path.resolve(path.join(__dirname, '../..')) ]}; 我們主要設定了 resolver 裡的 extraNodeModules 為根目錄的 node_modules 設定 watchFolders 監看整個專案 5. 測試看看吧我們分別在 app 跟 web 的 App.tsx 元件裡使用剛剛從 common 裡 export 的 function 測試 Appimport { testFunction } from '@todo/common'const App = () =&gt; { testFunction() const isDarkMode = useColorScheme() === 'dark'; const backgroundStyle = { backgroundColor: isDarkMode ? Colors.darker : Colors.lighter, }; return ( &lt;SafeAreaView style={backgroundStyle}&gt; // ... 以下省略 &lt;/SafeAreaView&gt; );}; 測試 Webimport React from 'react';import logo from './logo.svg';import './App.css';import { testFunction } from '@todo/common';function App() { testFunction() return ( // ...省略 );}export default App; web 的 App.tsx","link":"/2022/05/04/%E5%BB%BA%E7%AB%8B-React-Web-%E5%92%8C-React-Native-%E7%9A%84-Monorepo/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"graphql","slug":"graphql","link":"/tags/graphql/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Computer Networking","slug":"Computer-Networking","link":"/tags/Computer-Networking/"},{"name":"Database","slug":"Database","link":"/tags/Database/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"react","slug":"react","link":"/tags/react/"}],"categories":[{"name":"Backend","slug":"Backend","link":"/categories/Backend/"}]}